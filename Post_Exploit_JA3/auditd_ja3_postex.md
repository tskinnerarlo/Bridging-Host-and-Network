# Post Exploit JA3 auditd rules
**Summary**: auditd cannot see JA3 (it only records syscalls, not TLS handshakes), so you can’t match a JA3 hash with pure audit rules. The reliable pattern is:

* Let a network sensor (e.g., **Suricata** or Zeek) compute JA3/JA3S from TLS.

* Use auditd to capture the host context (who/what connected).

* Add a tiny audispd plugin that watches Suricata’s EVE JSON for JA3 hits from your watchlist and emits an AUDIT-ALERT into syslog/journald (so your alerting “lives” in the audit pipeline and correlates with your process/exec records). 
* Could also just send suricata JA3 alerts and auditd alerts to SIEM and use SIEM correlation engine to trigger alerts, but including JA3 alerts in auditd pipeline is probably more effiecient, and perhaps less false positives, with more greatly enriched alerts

Below is a ready-to-drop bundle: auditd rules + a small audispd plugin + tests.

# auditd rules (host context for correlation)
Create /etc/audit/rules.d/tls_ja3_postes.auditd.rules:
```bash
###############################################################################
# EXECVE: capture process launches by interactive users (gives argv, cwd, exe)
###############################################################################
-a always,exit -F arch=b64 -S execve -F auid>=1000 -F auid!=4294967295 -k user_exec
-a always,exit -F arch=b32 -S execve -F auid>=1000 -F auid!=4294967295 -k user_exec

###############################################################################
# CONNECT: capture successful outbound TCP connect() by interactive users
# NOTE: We cannot filter by JA3 here; this just records who connected to where.
###############################################################################
-a always,exit -F arch=b64 -S connect -F auid>=1000 -F auid!=4294967295 -F success=1 -k user_connect
-a always,exit -F arch=b32 -S connect -F auid>=1000 -F auid!=4294967295 -F success=1 -k user_connect

###############################################################################
# (Optional) SEND SIZE: large sends (volume context that often accompanies C2/exfil)
###############################################################################
-a always,exit -F arch=b64 -S sendto,sendmsg -F auid>=1000 -F auid!=4294967295 -F a2>=1048576 -k large_send_1mb
-a always,exit -F arch=b32 -S sendto,sendmsg -F auid>=1000 -F auid!=4294967295 -F a2>=1048576 -k large_send_1mb
```
Load/reload:
```bash
sudo augenrules --load
# or: sudo service auditd restart
```
**Why these rules?**

```execve``` gives you CommandLine, ```exe```, ```uid/auid```, etc.—crucial to understand which process generated a **JA3-flagged flow**.

```connect``` gives you socket destination (```SOCKADDR``` record: IP/port/family) so you can line up process/time with Suricata’s JA3 event.

(Optional) ```sendto/sendmsg``` with a byte threshold adds volume context (often elevated for C2/file staging), even though JA3 matching itself happens in Suricata.

# audispd plugin: alert when Suricata reports a JA3 on your watchlist
This lightweight plugin subscribes to auditd (stdin) and tails Suricata’s EVE log to raise AUDIT-ALERT lines on JA3 matches. Place it at ```/usr/local/sbin/audispd-ja3-watch```:
```bash
#!/usr/bin/env python3
import sys, os, time, json, re

# --- CONFIG ---
EVE_PATH = "/var/log/suricata/eve.json"   # adjust if different
WATCHLIST = "/etc/suricata/ja3_watchlist.txt"  # one md5 per line (lowercase)
# ---------------

def load_watchlist(path):
    s = set()
    try:
        with open(path) as f:
            for ln in f:
                ln = ln.strip().lower()
                if re.fullmatch(r"[0-9a-f]{32}", ln):
                    s.add(ln)
    except Exception:
        pass
    return s

def tail_eve(path):
    """Simple tail -F: reopen on rotation."""
    pos = 0
    fh = None
    ino = None
    while True:
        try:
            st = os.stat(path)
            if fh is None or st.st_ino != ino:
                if fh: fh.close()
                fh = open(path, "r", buffering=1)
                ino = st.st_ino
                fh.seek(0, os.SEEK_END)
        except FileNotFoundError:
            time.sleep(1); continue

        line = fh.readline()
        if not line:
            time.sleep(0.2)
            continue
        yield line

def emit_alert(ts, msg):
    # audispd will forward stdout to syslog/journald
    print(f"{ts} AUDIT-ALERT JA3 match: {msg}", flush=True)

def main():
    wl = load_watchlist(WATCHLIST)
    last_reload = time.time()

    for line in tail_eve(EVE_PATH):
        # hot-reload watchlist every 30s
        if time.time() - last_reload > 30:
            wl = load_watchlist(WATCHLIST)
            last_reload = time.time()

        try:
            ev = json.loads(line)
        except Exception:
            continue

        if ev.get("event_type") != "tls":
            continue

        # Suricata variants: .tls.ja3.hash OR .ja3.hash (version-dependent)
        ja3 = (
            ev.get("tls", {}).get("ja3", {}).get("hash") or
            ev.get("ja3", {}).get("hash")
        )
        if not ja3: 
            continue
        j = ja3.lower()

        if j in wl:
            ts = ev.get("timestamp", time.strftime("%Y-%m-%dT%H:%M:%S%z"))
            s = ev.get("src_ip", "?"); sp = ev.get("src_port", "?")
            d = ev.get("dest_ip", "?"); dp = ev.get("dest_port", "?")
            sni = ev.get("tls", {}).get("sni") or ev.get("sni")
            emit_alert(ts, f"ja3={j} src={s}:{sp} dst={d}:{dp} sni={sni or '-'}")
            # NOTE: For PID/EXE correlation, join in SIEM on near-time
            # with audit records keyed user_connect/user_exec.

if __name__ == "__main__":
    main()
```
Make it executable:
```bash
sudo chmod 0755 /usr/local/sbin/audispd-ja3-watch
```
Enable as an audisp plugin: ```/etc/audisp/plugins.d/ja3_watch.conf```
```ini
active = yes
direction = in
path = /usr/local/sbin/audispd-ja3-watch
type = always
format = string
```
Restart auditd:
```bash
sudo service auditd restart
```
Create the JA3 watchlist (lowercase md5, one per line):
```bash
sudo tee /etc/suricata/ja3_watchlist.txt >/dev/null <<'EOF'
72a589da586844d7f0818ce684948eea
a0e9f5d64349fb13191bc781f81f42e1
5d65ea3fb1d4aa7d826733d2f2cbbb1d
19e29534fd49dd27d09234e639c4057e
db42e3017c8b6d160751ef3a04f695e7
EOF
```
These examples are commonly cited in research as showing up with C2/post-ex frameworks (Cobalt Strike/Metasploit/Sliver/Python stacks). Expect collisions with benign apps; keep this as a hunting list and tune for your environment.

# Why this works
* JA3 lives at the TLS handshake, which auditd cannot see. Suricata (or Zeek) parses the ClientHello and computes JA3 md5; we watch those events.

* The audisp plugin bridges that intel back into your audit pipeline, producing AUDIT-ALERT lines you can ship to your SIEM alongside execve/connect host telemetry.

* The audit rules ensure you have rich process context (who ran what, and where they connected) to quickly pivot from a JA3 hit to the responsible process/user.

# Implementation checklist
Ensure Suricata is producing JA3 (in suricata.yaml):
```yaml
app-layer:
  protocols:
    tls:
      enabled: yes
      ja3-fingerprints: yes
outputs:
  - eve-log:
      enabled: yes
      types: [tls, alert, flow, http]
      filetype: regular
      filename: eve.json
```
Reload Suricata.

**Drop in the audit rules** and reload ```auditd```.

**Install the audisp plugin** + **watchlist**.

**Forward logs** to your SIEM and build a view/detection that correlates:

* ```AUDIT-ALERT JA3 match``` (plugin)

* ```user_connect``` (connect syscall around same time/tuple)

* ```user_exec``` (parent process/command line context)

# How to test (two simple paths)
**Self-test with a benign JA3**

* From the test host, visit a JA3 fingerprinting site (e.g., with a browser or curl https://ja3er.com/json, use https://ja3.zone/ in browser).

* Copy the md5 shown for your client into ```/etc/suricata/ja3_watchlist.txt.```

* Generate any HTTPS traffic (browse to any site).

* Expected: ```journalctl -u auditd -S "2 minutes ago" | grep -i "AUDIT-ALERT JA3 match"``` shows your JA3 hit with src/dst and SNI.

* Also check ```ausearch``` for surrounding context:
```bash
sudo ausearch -k user_connect -i --start recent | tail -n +50
sudo ausearch -k user_exec -i --start recent | tail -n +50
```


**CAP replay (Cobalt Strike example)**

* Download a public pcap that contains CS TLS handshakes.

* Run Suricata offline:
```bash
suricata -r ./cs_sample.pcap -l /tmp/eve-test
```
If you point the plugin at ```/tmp/eve-test/eve.json``` (update ```EVE_PATH```), you should see the alert if the pcap’s JA3 is on your watchlist.

**Tip**: to avoid touching your production EVE file during a replay, temporarily change ```EVE_PATH``` in the plugin to the test file, run the pcap, confirm alerts, then switch back.

# Tuning & hardening

* Prune the watchlist using your intel feeds; add/remove entries without restarting (the plugin hot-reloads every 30s).

* **Scope auditd load**: If you see overhead, add constraints (e.g., ```-F exe=/usr/bin/curl``` lines for high-chatter jump boxes) or throttle ```sendto``` size checks.

* **Reduce FPs**: Treat single JA3 hits as **hunt seeds**; require corroboration (JA3S match, SNI, cert anomalies, process name/location, parent process).

* **Alternate sensors**: Works the same with Zeek (ssl.log has ja3 fields). Just point EVE_PATH to the Zeek JSON (or adapt parser) and keep the rest unchanged.
