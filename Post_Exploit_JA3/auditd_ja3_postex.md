# Post Exploit JA3 auditd rules
**Summary**: auditd cannot see JA3 (it only records syscalls, not TLS handshakes), so you can’t match a JA3 hash with pure audit rules. The reliable pattern is:

* Let a network sensor (e.g., **Suricata** or Zeek) compute JA3/JA3S from TLS.

* Use auditd to capture the host context (who/what connected).

* Add a tiny audispd plugin that watches Suricata’s EVE JSON for JA3 hits from your watchlist and emits an AUDIT-ALERT into syslog/journald (so your alerting “lives” in the audit pipeline and correlates with your process/exec records). 
* Could also just send suricata JA3 alerts and auditd alerts to SIEM and use SIEM correlation engine to trigger alerts, but including JA3 alerts in auditd pipeline is probably more effiecient, and perhaps less false positives, with more greatly enriched alerts

Below is a ready-to-drop bundle: auditd rules + a small audispd plugin + tests.

# auditd rules (host context for correlation)
Create /etc/audit/rules.d/tls_ja3_postes.auditd.rules:
```bash
###############################################################################
# EXECVE: capture process launches by interactive users (gives argv, cwd, exe)
###############################################################################
-a always,exit -F arch=b64 -S execve -F auid>=1000 -F auid!=4294967295 -k user_exec
-a always,exit -F arch=b32 -S execve -F auid>=1000 -F auid!=4294967295 -k user_exec

###############################################################################
# CONNECT: capture successful outbound TCP connect() by interactive users
# NOTE: We cannot filter by JA3 here; this just records who connected to where.
###############################################################################
-a always,exit -F arch=b64 -S connect -F auid>=1000 -F auid!=4294967295 -F success=1 -k user_connect
-a always,exit -F arch=b32 -S connect -F auid>=1000 -F auid!=4294967295 -F success=1 -k user_connect

###############################################################################
# (Optional) SEND SIZE: large sends (volume context that often accompanies C2/exfil)
###############################################################################
-a always,exit -F arch=b64 -S sendto,sendmsg -F auid>=1000 -F auid!=4294967295 -F a2>=1048576 -k large_send_1mb
-a always,exit -F arch=b32 -S sendto,sendmsg -F auid>=1000 -F auid!=4294967295 -F a2>=1048576 -k large_send_1mb
```
Load/reload:
```bash
sudo augenrules --load
# or: sudo service auditd restart
```
**Why these rules?**

```execve``` gives you CommandLine, ```exe```, ```uid/auid```, etc.—crucial to understand which process generated a **JA3-flagged flow**.

```connect``` gives you socket destination (```SOCKADDR``` record: IP/port/family) so you can line up process/time with Suricata’s JA3 event.

(Optional) ```sendto/sendmsg``` with a byte threshold adds volume context (often elevated for C2/file staging), even though JA3 matching itself happens in Suricata.

# audispd plugin: alert when Suricata reports a JA3 on your watchlist
This lightweight plugin subscribes to auditd (stdin) and tails Suricata’s EVE log to raise AUDIT-ALERT lines on JA3 matches. Place it at ```/usr/local/sbin/audispd-ja3-watch```:
```bash
#!/usr/bin/env python3
import sys, os, time, json, re

# --- CONFIG ---
EVE_PATH = "/var/log/suricata/eve.json"   # adjust if different
WATCHLIST = "/etc/suricata/ja3_watchlist.txt"  # one md5 per line (lowercase)
# ---------------

def load_watchlist(path):
    s = set()
    try:
        with open(path) as f:
            for ln in f:
                ln = ln.strip().lower()
                if re.fullmatch(r"[0-9a-f]{32}", ln):
                    s.add(ln)
    except Exception:
        pass
    return s

def tail_eve(path):
    """Simple tail -F: reopen on rotation."""
    pos = 0
    fh = None
    ino = None
    while True:
        try:
            st = os.stat(path)
            if fh is None or st.st_ino != ino:
                if fh: fh.close()
                fh = open(path, "r", buffering=1)
                ino = st.st_ino
                fh.seek(0, os.SEEK_END)
        except FileNotFoundError:
            time.sleep(1); continue

        line = fh.readline()
        if not line:
            time.sleep(0.2)
            continue
        yield line

def emit_alert(ts, msg):
    # audispd will forward stdout to syslog/journald
    print(f"{ts} AUDIT-ALERT JA3 match: {msg}", flush=True)

def main():
    wl = load_watchlist(WATCHLIST)
    last_reload = time.time()

    for line in tail_eve(EVE_PATH):
        # hot-reload watchlist every 30s
        if time.time() - last_reload > 30:
            wl = load_watchlist(WATCHLIST)
            last_reload = time.time()

        try:
            ev = json.loads(line)
        except Exception:
            continue

        if ev.get("event_type") != "tls":
            continue

        # Suricata variants: .tls.ja3.hash OR .ja3.hash (version-dependent)
        ja3 = (
            ev.get("tls", {}).get("ja3", {}).get("hash") or
            ev.get("ja3", {}).get("hash")
        )
        if not ja3: 
            continue
        j = ja3.lower()

        if j in wl:
            ts = ev.get("timestamp", time.strftime("%Y-%m-%dT%H:%M:%S%z"))
            s = ev.get("src_ip", "?"); sp = ev.get("src_port", "?")
            d = ev.get("dest_ip", "?"); dp = ev.get("dest_port", "?")
            sni = ev.get("tls", {}).get("sni") or ev.get("sni")
            emit_alert(ts, f"ja3={j} src={s}:{sp} dst={d}:{dp} sni={sni or '-'}")
            # NOTE: For PID/EXE correlation, join in SIEM on near-time
            # with audit records keyed user_connect/user_exec.

if __name__ == "__main__":
    main()
```
Make it executable:
```bash
sudo chmod 0755 /usr/local/sbin/audispd-ja3-watch
```
Enable as an audisp plugin: ```/etc/audisp/plugins.d/ja3_watch.conf```
```ini
active = yes
direction = in
path = /usr/local/sbin/audispd-ja3-watch
type = always
format = string
```
Restart auditd:
```bash
sudo service auditd restart
```
Create the JA3 watchlist (lowercase md5, one per line):
```bash
sudo tee /etc/suricata/ja3_watchlist.txt >/dev/null <<'EOF'
72a589da586844d7f0818ce684948eea
a0e9f5d64349fb13191bc781f81f42e1
5d65ea3fb1d4aa7d826733d2f2cbbb1d
19e29534fd49dd27d09234e639c4057e
db42e3017c8b6d160751ef3a04f695e7
EOF
```
These examples are commonly cited in research as showing up with C2/post-ex frameworks (Cobalt Strike/Metasploit/Sliver/Python stacks). Expect collisions with benign apps; keep this as a hunting list and tune for your environment.

# Why this works
* JA3 lives at the TLS handshake, which auditd cannot see. Suricata (or Zeek) parses the ClientHello and computes JA3 md5; we watch those events.

* The audisp plugin bridges that intel back into your audit pipeline, producing AUDIT-ALERT lines you can ship to your SIEM alongside execve/connect host telemetry.

* The audit rules ensure you have rich process context (who ran what, and where they connected) to quickly pivot from a JA3 hit to the responsible process/user.

