# Post Exploit JA3 Sysmon for Linux rules
Summary: Sysmon for Linux cannot see or compute JA3/JA3S (that comes from parsing TLS handshakes on the wire). But you can still build a clean, repeatable detection by:

* Letting a network sensor (Suricata/Zeek) compute JA3 and flag watch-listed hashes,

* Using Sysmon for Linux to capture the host context (who/what made the connection), and

* Correlating the two (in your SIEM or with a tiny helper) so your alert points at an exact process + user.

The following notes provide:

*   A Sysmon-for-Linux ruleset (XML) that collects only the context you need,

*   A correlation plan (with example Splunk SPL) that “alerts on JA3” while attributing to the process,

*   Implementation steps, and

*   Easy tests you can run right away.
  
# Sysmon for Linux rules (drop-in XML)
Save as ```sysmon-ja3-context.xml```[copy included in github] and load it (steps below). These rules keep signal high and noise low by focusing on processes commonly used in post-ex/C2 and on outbound connections.
```xml
<Sysmon schemaversion="4.50">
  <EventFiltering>

    <!-- ===========================================================
         PROCESS CREATE (Event ID 1)
         Capture execution context for common C2/upload tools and
         anything launched from temp-like dirs (living-off-the-land).
         =========================================================== -->
    <ProcessCreate onmatch="include">

      <!-- Net/transfer tooling frequently used in staging/exfil -->
      <RuleGroup name="NetTools_Exec" groupRelation="or">
        <Image condition="end with">/curl</Image>
        <Image condition="end with">/wget</Image>
        <Image condition="end with">/python</Image>
        <Image condition="end with">/python3</Image>
        <Image condition="end with">/openssl</Image>
        <Image condition="end with">/socat</Image>
        <Image condition="end with">/ncat</Image>
        <Image condition="end with">/nc</Image>
      </RuleGroup>

      <!-- Suspicious execution locations -->
      <RuleGroup name="Tmp_Exec" groupRelation="and">
        <Image condition="contains any">/tmp/|/dev/shm/|/var/tmp/</Image>
      </RuleGroup>

      <!-- Heuristic: obvious upload/HTTP flags (helps triage) -->
      <RuleGroup name="Upload_Flags" groupRelation="and">
        <CommandLine condition="contains any">--data-binary @|-d @|--upload-file|-T|-F|--form|https://</CommandLine>
      </RuleGroup>
    </ProcessCreate>

    <!-- ===========================================================
         NETWORK CONNECT (Event ID 3)
         Attribute outbound connections to the originating process.
         =========================================================== -->
    <NetworkConnect onmatch="include">

      <!-- Any egress from our short list of net tools -->
      <RuleGroup name="NetTools_Egress" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <Image condition="end with">/curl</Image>
      </RuleGroup>
      <RuleGroup name="NetTools_Egress" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <Image condition="end with">/wget</Image>
      </RuleGroup>
      <RuleGroup name="NetTools_Egress" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <Image condition="end with">/python3</Image>
      </RuleGroup>
      <RuleGroup name="NetTools_Egress" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <Image condition="end with">/openssl</Image>
      </RuleGroup>
      <RuleGroup name="NetTools_Egress" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <Image condition="end with">/socat</Image>
      </RuleGroup>
      <RuleGroup name="NetTools_Egress" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <Image condition="end with">/ncat</Image>
      </RuleGroup>

      <!-- Common TLS ports (optional narrowing) -->
      <RuleGroup name="TLSish_Ports" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <DestinationPort condition="is">443</DestinationPort>
      </RuleGroup>
      <RuleGroup name="TLSish_Ports" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <DestinationPort condition="is">8443</DestinationPort>
      </RuleGroup>
      <RuleGroup name="TLSish_Ports" groupRelation="and">
        <Initiated condition="is">true</Initiated>
        <DestinationPort condition="is">9443</DestinationPort>
      </RuleGroup>
    </NetworkConnect>

  </EventFiltering>
</Sysmon>
```
**Why these Sysmon rules?**

They don’t try to match JA3 (impossible at host syscall level) — they preserve the who/what:

*   Event ID 1 gives Image, CommandLine, ParentImage, User, etc. so you can attribute a JA3 hit to a specific process and parent.

*   Event ID 3 gives DestinationIp/Port and Initiated=true, which you’ll time-join to the network sensor’s JA3 record.

*   Focus on curl/wget/python3/openssl/socat/nc and temp dirs reduces volume while catching a large share of post-exfil techniques.

# Correlate JA3 from Suricata/Zeek to Sysmon (example with Splunk)
Create a JA3 watchlist (CSV) and a correlation search that joins Suricata’s JA3 hits to Sysmon NetworkConnect and ProcessCreate in a short time window.

```ja3_watchlist.csv```
```
ja3_hash,tag
72a589da586844d7f0818ce684948eea,cobalt_strike_common
a0e9f5d64349fb13191bc781f81f42e1,metasploit_alt
5d65ea3fb1d4aa7d826733d2f2cbbb1d,meterpreter_linux
19e29534fd49dd27d09234e639c4057e,sliver_go_tls
db42e3017c8b6d160751ef3a04f695e7,python_empire_poshc2
```
Import the ja3_watchlist.csv file into Splunk as a lookup file that can be used as part of an SPL query which will be defined below. 

<br>Now write the correlation SPL:
```spl
/* 1) JA3 hit from Suricata EVE (tls events) */
index=net_suricata event_type=tls
| eval ja3=coalesce('tls.ja3.hash','ja3.hash')
| lookup ja3_watchlist.csv ja3_hash as ja3 OUTPUT tag
| where isnotnull(tag)
| eval src=src_ip, dst=dest_ip, dport=dest_port
| bin _time span=5s
| table _time src dst dport ja3 tag tls.sni

/* 2) Join Sysmon-Linux NetworkConnect by 5-tuple + time bucket */
| join type=left _time src dst dport
    [ search index=sysmon_linux EventID=3 Initiated=true
      | eval src=SourceIp, dst=DestinationIp, dport=DestinationPort
      | bin _time span=5s
      | stats latest(Image) as Image latest(CommandLine) as CommandLine latest(User) as User by _time src dst dport ]

/* 3) Pull in the creating process (EID 1) for richer context */
| join type=left User [ search index=sysmon_linux EventID=1
                        | stats latest(Image) as ParentImage latest(CommandLine) as ParentCmd by User ]
| rename tls.sni as sni
| fields _time tag ja3 sni src dst dport User Image CommandLine ParentImage ParentCmd
```
**Result**: an alert like
“JA3=cobalt_strike_common to 203.0.113.10:443 by /usr/bin/curl (user ```devops```, cmdline ```curl --data-binary @/tmp/db.sql https://...```)”

# Implementation steps
1. Install/verify Sysmon for Linux (service running, events reaching your log pipeline).

2. Load the XML
```bash
sudo cp /etc/sysmon/sysmon.xml /etc/sysmon/sysmon.xml.bak 2>/dev/null || true
sudo tee /etc/sysmon/sysmon-ja3-context.xml >/dev/null < sysmon-ja3-context.xml
sudo sysmon -c /etc/sysmon/sysmon-ja3-context.xml
```
3. Ensure Suricata (or Zeek) is emitting JA3
In ```suricata.yaml```:
```yaml
app-layer:
  protocols:
    tls:
      enabled: yes
      ja3-fingerprints: yes
outputs:
  - eve-log:
      enabled: yes
      types: [tls, alert, flow]
      filename: eve.json
```
4. Create the JA3 watchlist lookup in your SIEM and add the correlation search above (schedule/threshold as you prefer).

# How to test (no malware required)
**Option A — “Plumbing test” with your own JA3**

1. From the monitored host, fetch your JA3:
```curl -s https://ja3er.com/json | jq -r .ja3_hash```
(or browse to a JA3 site and note the md5)

2. Add that md5 to ```ja3_watchlist.csv``` with a test tag (e.g., ```test_ja3```).

4. Generate any HTTPS traffic from the host (e.g., curl ```https://example.com/```).

4. In Splunk, run the correlation search; you should see an alert with your Image/CommandLine from Sysmon and the JA3 from Suricata.

**Option B — PCAP replay with known JA3**

1. Get a public pcap that contains a known Cobalt Strike or Sliver JA3.

2. Run Suricata offline:
```suricata -r sample.pcap -l /tmp/eve-test```
(point your SIEM or a quick script at ```/tmp/eve-test/eve.json)```, ensure your watchlist includes the pcap’s JA3.

3. You should see the JA3 hit; if the pcap came from a different host, the Sysmon side won’t have a matching event — that’s expected for an offline replay; the goal is validating the JA3 path.

# Notes & tuning
*   JA3 ≠ attribution. Many tools can randomize TLS or impersonate browsers. Treat these as hunt seeds; pair with SNI/cert intel and process lineage.

*   Noise control: If dev boxes legitimately run curl uploads, add an exclude ProcessCreate block for known users/groups, or restrict the NetworkConnect filter to specific subnets/ports you care about.

*   Broaden scope: If your environment uses other client stacks (e.g., rclone, aws, az, custom Go binaries), add them to NetTools_Exec and NetTools_Egress.

*   MITRE mapping: T1071.001 (Web Protocols), T1573 (Encrypted Channel), T1105 (Ingress Tool Transfer) — depending on context.
